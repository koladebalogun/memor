{"ast":null,"code":"// A reducer is a function that accepts the state and action then based on the action type, it carries out a logic\nimport { FETCH_ALL, FETCH_POST, FETCH_BY_SEARCH, CREATE, UPDATE, DELETE, START_LOADING, END_LOADING } from '../constants/actionTypes'; // This is where we recreate our actions\n\nexport default (function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    isLoading: true,\n    posts: []\n  };\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    //*** FOR NORMAL POSTS ***\n    // case FETCH_ALL: //for fetching all post\n    //   return action.payload;\n    case START_LOADING:\n      return { ...state,\n        isLoading: true\n      };\n\n    case END_LOADING:\n      return { ...state,\n        isLoading: false\n      };\n    //****FOR POSTS WITH PAGES */\n    // we have to always spread the state when working with objects\n    //and our post would be Post: action.payload\n\n    case FETCH_ALL:\n      return { ...state,\n        posts: action.payload.data,\n        //here our post would be equal to action.payload.data\n        currentPage: action.payload.currentPage,\n        numberOfPages: action.payload.numberOfPages\n      };\n\n    case CREATE:\n      //for creating new posts\n      return { ...state,\n        posts: [...state.posts, action.payload]\n      };\n    //the posts would be added to the action.payload\n\n    case START_LOADING:\n      return { ...state,\n        isLoading: true\n      };\n\n    case END_LOADING:\n      return { ...state,\n        isLoading: false\n      };\n\n    case FETCH_BY_SEARCH:\n      return { ...state,\n        posts: action.payload\n      };\n\n    case FETCH_POST:\n      return { ...state,\n        post: action.payload\n      };\n\n    case DELETE:\n      return { ...state,\n        posts: state.posts.filter(post => post._id !== action.payload)\n      };\n    // we're returning all the posts, but filtering out the one we deleted\n\n    case UPDATE:\n      return { ...state,\n        posts: state.posts.map(post => post._id === action.payload._id ? action.payload : post)\n      };\n\n    default:\n      return state;\n  }\n}); //Note \n//For the UPDATE CASE\n//*action.payload is the updated post** so if  \n//the post id is equal to action.payload id, we want to return the action.payload. Because action.payload is the newly updated post. else we return the post as it was without any updates ***** */\n//^^","map":{"version":3,"sources":["/Users/koladebalogun/Desktop/Memoirs project/client/src/reducers/posts.js"],"names":["FETCH_ALL","FETCH_POST","FETCH_BY_SEARCH","CREATE","UPDATE","DELETE","START_LOADING","END_LOADING","state","isLoading","posts","action","type","payload","data","currentPage","numberOfPages","post","filter","_id","map"],"mappings":"AAAA;AAEA,SAASA,SAAT,EAAoBC,UAApB,EAAgCC,eAAhC,EAAiDC,MAAjD,EAAyDC,MAAzD,EAAkEC,MAAlE,EAA0EC,aAA1E,EAAyFC,WAAzF,QAA4G,0BAA5G,C,CAGA;;AACA,gBAAe,YAAoD;AAAA,MAAnDC,KAAmD,uEAA3C;AAAEC,IAAAA,SAAS,EAAE,IAAb;AAAmBC,IAAAA,KAAK,EAAE;AAA1B,GAA2C;AAAA,MAAXC,MAAW;;AACjE,UAAQA,MAAM,CAACC,IAAf;AAEE;AACA;AACA;AAEA,SAAKN,aAAL;AACE,aAAO,EAAE,GAAGE,KAAL;AAAYC,QAAAA,SAAS,EAAE;AAAvB,OAAP;;AACF,SAAKF,WAAL;AACE,aAAO,EAAE,GAAGC,KAAL;AAAYC,QAAAA,SAAS,EAAE;AAAvB,OAAP;AAEF;AAEA;AACA;;AACA,SAAKT,SAAL;AACE,aAAO,EACL,GAAGQ,KADE;AAELE,QAAAA,KAAK,EAAEC,MAAM,CAACE,OAAP,CAAeC,IAFjB;AAEuB;AAC5BC,QAAAA,WAAW,EAAEJ,MAAM,CAACE,OAAP,CAAeE,WAHvB;AAILC,QAAAA,aAAa,EAAEL,MAAM,CAACE,OAAP,CAAeG;AAJzB,OAAP;;AAMF,SAAKb,MAAL;AAAa;AACX,aAAO,EAAC,GAAGK,KAAJ;AAAWE,QAAAA,KAAK,EAAC,CAAE,GAAGF,KAAK,CAACE,KAAX,EAAkBC,MAAM,CAACE,OAAzB;AAAjB,OAAP;AAA4D;;AAC5D,SAAKP,aAAL;AACE,aAAO,EAAE,GAAGE,KAAL;AAAYC,QAAAA,SAAS,EAAE;AAAvB,OAAP;;AACF,SAAKF,WAAL;AACE,aAAO,EAAE,GAAGC,KAAL;AAAYC,QAAAA,SAAS,EAAE;AAAvB,OAAP;;AACJ,SAAKP,eAAL;AACE,aAAO,EAAC,GAAGM,KAAJ;AAAWE,QAAAA,KAAK,EAAEC,MAAM,CAACE;AAAzB,OAAP;;AACF,SAAKZ,UAAL;AACE,aAAO,EAAC,GAAGO,KAAJ;AAAWS,QAAAA,IAAI,EAAEN,MAAM,CAACE;AAAxB,OAAP;;AACF,SAAKR,MAAL;AACE,aAAO,EAAC,GAAGG,KAAJ;AAAWE,QAAAA,KAAK,EAAGF,KAAK,CAACE,KAAN,CAAYQ,MAAZ,CAAoBD,IAAD,IAAUA,IAAI,CAACE,GAAL,KAAaR,MAAM,CAACE,OAAjD;AAAnB,OAAP;AAAsF;;AACxF,SAAKT,MAAL;AACE,aAAO,EAAC,GAAGI,KAAJ;AAAWE,QAAAA,KAAK,EAAEF,KAAK,CAACE,KAAN,CAAYU,GAAZ,CAAiBH,IAAD,IACvCA,IAAI,CAACE,GAAL,KAAaR,MAAM,CAACE,OAAP,CAAeM,GAA5B,GAAkCR,MAAM,CAACE,OAAzC,GAAmDI,IAD5B;AAAlB,OAAP;;AAIF;AACE,aAAOT,KAAP;AAxCJ;AA0CD,CA3CD,E,CA6CA;AACA;AACA;AACA;AAEA","sourcesContent":["// A reducer is a function that accepts the state and action then based on the action type, it carries out a logic\n\nimport { FETCH_ALL, FETCH_POST, FETCH_BY_SEARCH, CREATE, UPDATE , DELETE, START_LOADING, END_LOADING } from '../constants/actionTypes';\n\n\n// This is where we recreate our actions\nexport default (state = { isLoading: true, posts: [] }, action) => {\n  switch (action.type) {\n\n    //*** FOR NORMAL POSTS ***\n    // case FETCH_ALL: //for fetching all post\n    //   return action.payload;\n\n    case START_LOADING:\n      return { ...state, isLoading: true };\n    case END_LOADING:\n      return { ...state, isLoading: false };\n\n    //****FOR POSTS WITH PAGES */\n\n    // we have to always spread the state when working with objects\n    //and our post would be Post: action.payload\n    case FETCH_ALL:\n      return {  \n        ...state,\n        posts: action.payload.data, //here our post would be equal to action.payload.data\n        currentPage: action.payload.currentPage,\n        numberOfPages: action.payload.numberOfPages,\n      };\n    case CREATE: //for creating new posts\n      return {...state, posts:[ ...state.posts, action.payload]}; //the posts would be added to the action.payload\n      case START_LOADING:\n        return { ...state, isLoading: true };\n      case END_LOADING:\n        return { ...state, isLoading: false };\n    case FETCH_BY_SEARCH:\n      return {...state, posts: action.payload }\n    case FETCH_POST:\n      return {...state, post: action.payload }\n    case DELETE:\n      return {...state, posts:  state.posts.filter((post) => post._id !== action.payload )} // we're returning all the posts, but filtering out the one we deleted\n    case UPDATE:\n      return {...state, posts: state.posts.map((post) =>\n        post._id === action.payload._id ? action.payload : post\n      )};\n\n    default:\n      return state;\n  }\n};\n\n//Note \n//For the UPDATE CASE\n//*action.payload is the updated post** so if  \n//the post id is equal to action.payload id, we want to return the action.payload. Because action.payload is the newly updated post. else we return the post as it was without any updates ***** */\n\n//^^"]},"metadata":{},"sourceType":"module"}